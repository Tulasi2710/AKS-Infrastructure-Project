name: 'Microservices Deployment'

on:
  push:
    branches: [ "main" ]
    paths:
      - 'k8s/**'
      - 'scripts/deploy-microservices.sh'
      - '.github/workflows/microservices.yml'
  pull_request:
    branches: [ "main" ]
    paths:
      - 'k8s/**'
      - 'scripts/deploy-microservices.sh'
      - '.github/workflows/microservices.yml'
  workflow_dispatch:
    inputs:
      aks_cluster_name:
        description: 'AKS Cluster Name'
        required: false
        default: 'aks-cluster-dev'
        type: string
      resource_group_name:
        description: 'Resource Group Name'
        required: false
        default: 'rg-aks-dev'
        type: string
      force_redeploy:
        description: 'Force redeploy all services'
        required: false
        default: 'false'
        type: boolean

permissions:
  id-token: write
  contents: read
  pull-requests: write

env:
  KUBECTL_VERSION: 'v1.28.0'

jobs:
  validate-manifests:
    name: 'Validate Kubernetes Manifests'
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}

    - name: Validate Kubernetes YAML files
      run: |
        echo "Validating Kubernetes manifests..."
        find k8s/ -name "*.yaml" -o -name "*.yml" | while read file; do
          echo "Validating $file..."
          kubectl apply --dry-run=client -f "$file"
        done

    - name: Check for required secrets
      run: |
        echo "Checking for required Kubernetes secrets..."
        grep -r "secretKeyRef\|valueFrom" k8s/ || echo "No secret references found"

  deploy-to-aks:
    name: 'Deploy to AKS'
    runs-on: ubuntu-latest
    needs: validate-manifests
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}

    - name: Get AKS credentials
      run: |
        # Use provided inputs or default values
        CLUSTER_NAME="${{ github.event.inputs.aks_cluster_name || 'aks-cluster-dev' }}"
        RG_NAME="${{ github.event.inputs.resource_group_name || 'rg-aks-dev' }}"
        
        echo "Connecting to AKS cluster: $CLUSTER_NAME in resource group: $RG_NAME"
        az aks get-credentials --resource-group "$RG_NAME" --name "$CLUSTER_NAME" --overwrite-existing

    - name: Verify cluster connectivity
      run: |
        echo "Verifying cluster connectivity..."
        kubectl cluster-info
        kubectl get nodes
        kubectl version --client --output=yaml

    - name: Check existing deployments
      run: |
        echo "=== CURRENT CLUSTER STATE ==="
        echo "Namespaces:"
        kubectl get namespaces | grep -E "(ecommerce|monitoring)" || echo "No application namespaces found"
        echo ""
        echo "Existing pods:"
        kubectl get pods --all-namespaces | grep -E "(ecommerce|monitoring)" || echo "No application pods found"

    - name: Deploy Namespaces
      run: |
        echo "Deploying namespaces..."
        kubectl apply -f k8s/namespaces/ecommerce-namespace.yaml
        
        echo "Waiting for namespaces to be active..."
        kubectl wait --for=condition=Active namespace/ecommerce --timeout=60s
        kubectl wait --for=condition=Active namespace/ecommerce-database --timeout=60s
        kubectl wait --for=condition=Active namespace/monitoring --timeout=60s

    - name: Deploy Database
      run: |
        echo "Deploying PostgreSQL database..."
        kubectl apply -f k8s/database/postgres-deployment.yaml
        
        echo "Waiting for database to be ready..."
        kubectl wait --for=condition=available --timeout=300s deployment/postgres -n ecommerce-database
        
        echo "Database deployment status:"
        kubectl get pods -n ecommerce-database
        kubectl get svc -n ecommerce-database

    - name: Deploy Backend Services
      run: |
        echo "Deploying backend services..."
        kubectl apply -f k8s/backend/backend-services.yaml
        
        echo "Waiting for backend services to be ready..."
        kubectl wait --for=condition=available --timeout=300s deployment/user-service -n ecommerce
        kubectl wait --for=condition=available --timeout=300s deployment/product-service -n ecommerce
        
        echo "Backend services status:"
        kubectl get pods -n ecommerce
        kubectl get svc -n ecommerce

    - name: Deploy Frontend
      run: |
        echo "Deploying frontend service..."
        kubectl apply -f k8s/frontend/frontend-deployment.yaml
        
        echo "Waiting for frontend to be ready..."
        kubectl wait --for=condition=available --timeout=300s deployment/frontend -n ecommerce
        
        echo "Frontend deployment status:"
        kubectl get pods -n ecommerce -l app=frontend
        kubectl get svc -n ecommerce -l app=frontend

    - name: Deploy Ingress Controller
      run: |
        echo "Deploying ingress configuration..."
        kubectl apply -f k8s/ingress/ingress-config.yaml
        
        echo "Ingress status:"
        kubectl get ingress -n ecommerce
        kubectl get svc -n ecommerce ecommerce-loadbalancer

    - name: Deploy Monitoring Stack
      run: |
        echo "Deploying monitoring stack (Prometheus + Grafana)..."
        kubectl apply -f k8s/monitoring/monitoring-stack.yaml
        
        echo "Waiting for monitoring services to be ready..."
        kubectl wait --for=condition=available --timeout=300s deployment/prometheus -n monitoring
        kubectl wait --for=condition=available --timeout=300s deployment/grafana -n monitoring
        
        echo "Monitoring stack status:"
        kubectl get pods -n monitoring
        kubectl get svc -n monitoring

    - name: Final Deployment Summary
      run: |
        echo "=================================="
        echo "üéâ MICROSERVICES DEPLOYMENT COMPLETE"
        echo "=================================="
        echo ""
        
        echo "üìä PODS STATUS:"
        echo "---------------"
        echo "E-commerce Pods:"
        kubectl get pods -n ecommerce -o wide
        echo ""
        echo "Database Pods:"
        kubectl get pods -n ecommerce-database -o wide
        echo ""
        echo "Monitoring Pods:"
        kubectl get pods -n monitoring -o wide
        echo ""
        
        echo "üåê SERVICES:"
        echo "------------"
        echo "E-commerce Services:"
        kubectl get svc -n ecommerce
        echo ""
        echo "Database Services:"
        kubectl get svc -n ecommerce-database
        echo ""
        echo "Monitoring Services:"
        kubectl get svc -n monitoring
        echo ""
        
        echo "üîÄ INGRESS:"
        echo "----------"
        kubectl get ingress -n ecommerce
        echo ""
        
        echo "üìà ACCESS INFORMATION:"
        echo "---------------------"
        
        # Get LoadBalancer IPs
        FRONTEND_IP=$(kubectl get svc ecommerce-loadbalancer -n ecommerce -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "Pending")
        GRAFANA_IP=$(kubectl get svc grafana-service -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "Pending")
        
        echo "Frontend Application:"
        if [ "$FRONTEND_IP" != "Pending" ] && [ "$FRONTEND_IP" != "" ]; then
          echo "  URL: http://$FRONTEND_IP"
          echo "  API Endpoints:"
          echo "    - User Service: http://$FRONTEND_IP/api/users"
          echo "    - Product Service: http://$FRONTEND_IP/api/products"
        else
          echo "  LoadBalancer IP: Pending (check later with: kubectl get svc ecommerce-loadbalancer -n ecommerce)"
        fi
        
        echo ""
        echo "Grafana Dashboard:"
        if [ "$GRAFANA_IP" != "Pending" ] && [ "$GRAFANA_IP" != "" ]; then
          echo "  URL: http://$GRAFANA_IP:3000"
          echo "  Username: admin"
          echo "  Password: admin123"
        else
          echo "  LoadBalancer IP: Pending (check later with: kubectl get svc grafana-service -n monitoring)"
        fi
        
        echo ""
        echo "üîç MONITORING COMMANDS:"
        echo "----------------------"
        echo "kubectl get pods --all-namespaces"
        echo "kubectl get svc --all-namespaces"
        echo "kubectl logs -f deployment/<deployment-name> -n <namespace>"

    - name: Health Check
      run: |
        echo "Performing health checks..."
        
        # Check if all pods are running
        FAILED_PODS=$(kubectl get pods --all-namespaces --field-selector=status.phase!=Running --no-headers 2>/dev/null | wc -l)
        if [ "$FAILED_PODS" -gt 0 ]; then
          echo "‚ö†Ô∏è Warning: $FAILED_PODS pods are not in Running state"
          kubectl get pods --all-namespaces --field-selector=status.phase!=Running
        else
          echo "‚úÖ All pods are running successfully"
        fi
        
        # Check service endpoints
        echo "Checking service endpoints..."
        kubectl get endpoints --all-namespaces