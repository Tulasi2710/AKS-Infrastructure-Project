name: 'Kubernetes Deployment with ArgoCD'

# PREREQUISITES: 
# This workflow requires an existing AKS cluster created by the Terraform pipeline.
# Run the infrastructure pipeline (terraform.yml) first to create the AKS cluster.

on:
  push:
    branches: [ "main" ]
    paths:
      - 'k8s/**'
      - 'argocd/**'
      - 'scripts/install-argocd.*'
      - '.github/workflows/gitops-argocd.yml'
  pull_request:
    branches: [ "main" ]
    paths:
      - 'k8s/**'
      - 'argocd/**'
      - 'scripts/install-argocd.*'
      - '.github/workflows/gitops-argocd.yml'
  workflow_dispatch:
    inputs:
      aks_cluster_name:
        description: 'AKS Cluster Name'
        required: true
        default: 'aks-cluster-dev'
        type: string
      resource_group_name:
        description: 'Resource Group Name'
        required: true
        default: 'rg-aks-dev'
        type: string
      action:
        description: 'Action to perform'
        required: false
        default: 'install-and-sync'
        type: choice
        options:
        - install-and-sync
        - install-only
        - sync-only
        - status
        - uninstall

permissions:
  id-token: write
  contents: read

env:
  KUBECTL_VERSION: 'v1.28.0'

jobs:
  validate-manifests:
    name: 'Validate Kubernetes & ArgoCD Manifests'
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}

    - name: Install Validation Tools
      run: |
        echo "� Installing validation tools..."
        
        # Install yq for YAML processing
        sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
        sudo chmod +x /usr/local/bin/yq
        
        # Install kubeval for Kubernetes validation
        wget https://github.com/instrumenta/kubeval/releases/latest/download/kubeval-linux-amd64.tar.gz
        tar xf kubeval-linux-amd64.tar.gz
        chmod +x kubeval
        sudo mv kubeval /usr/local/bin
        
        echo "✅ Validation tools installed"

    - name: Validate Kubernetes Manifests
      run: |
        echo "🔍 Validating Kubernetes application manifests..."
        if [ -d "k8s" ]; then
          validation_failed=false
          
          find k8s/ -name "*.yaml" -o -name "*.yml" | while read file; do
            echo "  📄 Validating $file"
            
            # Check if file is empty or has only comments
            if [ ! -s "$file" ] || ! grep -q '[^[:space:]]' "$file"; then
              echo "  ⚠️  Empty file, skipping: $file"
              continue
            fi
            
            # Validate YAML syntax using yq
            if ! yq eval '.' "$file" > /dev/null 2>&1; then
              echo "  ❌ Invalid YAML syntax in $file"
              validation_failed=true
              continue
            fi
            
            # Validate Kubernetes schema using kubeval
            if kubeval "$file" > /dev/null 2>&1; then
              echo "  ✅ Valid Kubernetes manifest: $file"
            else
              echo "  ⚠️  Kubeval validation failed for $file (may be a custom resource)"
              echo "  ✅ YAML syntax is valid, proceeding..."
            fi
          done
          
          if [ "$validation_failed" = true ]; then
            echo "❌ Some manifest validations failed"
            exit 1
          fi
          
          echo "✅ All Kubernetes manifests passed validation"
        else
          echo "⚠️  No k8s directory found - skipping K8s validation"
        fi

    - name: Validate ArgoCD Manifests
      run: |
        echo "🔍 Validating ArgoCD manifests..."
        if [ -d "argocd" ]; then
          validation_failed=false
          
          find argocd/ -name "*.yaml" -o -name "*.yml" | while read file; do
            echo "  📄 Validating $file"
            
            # Check if file is empty
            if [ ! -s "$file" ] || ! grep -q '[^[:space:]]' "$file"; then
              echo "  ⚠️  Empty file, skipping: $file"
              continue
            fi
            
            # Validate YAML syntax using yq
            if ! yq eval '.' "$file" > /dev/null 2>&1; then
              echo "  ❌ Invalid YAML syntax in $file"
              validation_failed=true
              continue
            fi
            
            # Check for basic Kubernetes/ArgoCD structure
            if yq eval '.apiVersion' "$file" > /dev/null 2>&1 && yq eval '.kind' "$file" > /dev/null 2>&1; then
              echo "  ✅ Valid manifest structure: $file"
            else
              echo "  ⚠️  No apiVersion/kind found in $file (may not be a K8s manifest)"
            fi
          done
          
          if [ "$validation_failed" = true ]; then
            echo "❌ Some ArgoCD manifest validations failed"
            exit 1
          fi
          
          echo "✅ All ArgoCD manifests passed validation"
        else
          echo "⚠️  No argocd directory found - skipping ArgoCD validation"
        fi

    - name: Check GitOps Configuration
      run: |
        echo "📋 Checking GitOps configuration..."
        if [ -f "argocd/applications.yaml" ]; then
          echo "Repository URLs in applications:"
          grep -r "repoURL:" argocd/ || echo "No repoURL found"
          echo ""
          echo "Application source paths:"
          grep -r "path:" argocd/ | grep -v "filepath" || echo "No paths found"
          echo ""
          echo "Target namespaces:"
          grep -r "namespace:" argocd/ || echo "No namespaces found"
        fi

  gitops-deployment:
    name: 'GitOps Deployment with ArgoCD'
    runs-on: ubuntu-latest
    needs: validate-manifests
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}

    - name: Discover and Connect to AKS Cluster
      run: |
        echo "🔍 Discovering AKS clusters in subscription..."
        
        # Try user-provided names first
        CLUSTER_NAME="${{ github.event.inputs.aks_cluster_name }}"
        RG_NAME="${{ github.event.inputs.resource_group_name }}"
        
        # If not provided, search for AKS clusters created by Terraform
        if [ -z "$CLUSTER_NAME" ] || [ -z "$RG_NAME" ]; then
          echo "📋 Searching for AKS clusters created by Terraform..."
          
          # List all AKS clusters and find the one created by Terraform
          AKS_CLUSTERS=$(az aks list --query "[?tags.Project=='aks-infra' && tags.Environment=='dev'].{name:name,resourceGroup:resourceGroup}" -o tsv 2>/dev/null || echo "")
          
          if [ -n "$AKS_CLUSTERS" ]; then
            # Get the first matching cluster
            CLUSTER_INFO=$(echo "$AKS_CLUSTERS" | head -n 1)
            CLUSTER_NAME=$(echo "$CLUSTER_INFO" | cut -f1)
            RG_NAME=$(echo "$CLUSTER_INFO" | cut -f2)
            
            echo "✅ Found Terraform-managed AKS cluster: $CLUSTER_NAME in $RG_NAME"
          else
            # Fallback to default names
            CLUSTER_NAME="aks-cluster-dev"
            RG_NAME="rg-aks-dev"
            echo "⚠️  No Terraform-managed clusters found, trying default names..."
          fi
        fi
        
        echo "🔗 Attempting to connect to AKS cluster: $CLUSTER_NAME in resource group: $RG_NAME"
        
        # Check if resource group exists
        if ! az group show --name "$RG_NAME" > /dev/null 2>&1; then
          echo "❌ Resource group '$RG_NAME' not found!"
          echo ""
          echo "💡 Available resource groups:"
          az group list --query "[].name" -o table
          echo ""
          echo "� Please ensure the infrastructure is deployed first using the Terraform pipeline."
          echo "   Or provide the correct cluster name and resource group name as workflow inputs."
          exit 1
        fi
        
        # Check if AKS cluster exists
        if ! az aks show --name "$CLUSTER_NAME" --resource-group "$RG_NAME" > /dev/null 2>&1; then
          echo "❌ AKS cluster '$CLUSTER_NAME' not found in resource group '$RG_NAME'!"
          echo ""
          echo "💡 Available AKS clusters in resource group:"
          az aks list --resource-group "$RG_NAME" --query "[].name" -o table 2>/dev/null || echo "No AKS clusters found"
          echo ""
          echo "🚨 Please ensure the infrastructure is deployed first using the Terraform pipeline."
          exit 1
        fi
        
        # Connect to the cluster
        echo "🔗 Connecting to AKS cluster..."
        az aks get-credentials --resource-group "$RG_NAME" --name "$CLUSTER_NAME" --overwrite-existing
        
        echo "✅ Connected to cluster successfully!"
        echo ""
        echo "📊 Cluster Information:"
        kubectl cluster-info
        echo ""
        echo "📋 Node Status:"
        kubectl get nodes
        
        # Export cluster details for subsequent jobs
        echo "DISCOVERED_CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV
        echo "DISCOVERED_RG_NAME=$RG_NAME" >> $GITHUB_ENV

    - name: Check Current ArgoCD Status
      continue-on-error: true
      run: |
        echo "📊 Checking current ArgoCD status..."
        kubectl get namespace argocd 2>/dev/null || echo "ArgoCD namespace not found"
        kubectl get pods -n argocd 2>/dev/null || echo "No ArgoCD pods found"

    - name: Install ArgoCD (Linux)
      if: github.event.inputs.action != 'uninstall' && github.event.inputs.action != 'status'
      run: |
        echo "🚀 Installing ArgoCD using installation script..."
        chmod +x scripts/install-argocd.sh
        ./scripts/install-argocd.sh

    - name: Verify ArgoCD Installation
      if: github.event.inputs.action != 'uninstall'
      run: |
        echo "🔍 Verifying ArgoCD installation..."
        
        # Check ArgoCD pods
        echo "ArgoCD Pods:"
        kubectl get pods -n argocd
        
        # Check ArgoCD applications
        echo ""
        echo "ArgoCD Applications:"
        kubectl get applications -n argocd || echo "No applications found yet"
        
        # Check services
        echo ""
        echo "ArgoCD Services:"
        kubectl get svc -n argocd

    - name: Get ArgoCD Access Information
      if: github.event.inputs.action != 'uninstall'
      run: |
        echo "🌐 ArgoCD Access Information:"
        echo "============================="
        
        # Get LoadBalancer IP
        ARGOCD_IP=$(kubectl get svc argocd-server-loadbalancer -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
        
        # Get admin password
        ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" 2>/dev/null | base64 -d || echo "Password not available")
        
        echo ""
        if [ ! -z "$ARGOCD_IP" ]; then
          echo "🎯 ArgoCD UI: https://$ARGOCD_IP"
          echo "Username: admin"
          echo "Password: $ARGOCD_PASSWORD"
        else
          echo "LoadBalancer IP: Pending"
          echo "Check later with: kubectl get svc argocd-server-loadbalancer -n argocd"
          echo "Username: admin"
          echo "Password: $ARGOCD_PASSWORD"
        fi
        
        echo ""
        echo "📋 GitOps Configuration:"
        echo "Repository: https://github.com/${{ github.repository }}"
        echo "Monitoring Path: k8s/"
        echo "Auto-sync: Enabled"

    - name: Uninstall ArgoCD
      if: github.event.inputs.action == 'uninstall'
      run: |
        echo "⚠️ Uninstalling ArgoCD..."
        
        # Delete applications first
        kubectl delete applications --all -n argocd --ignore-not-found=true
        
        # Delete ArgoCD installation
        kubectl delete -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml --ignore-not-found=true
        
        # Delete namespace
        kubectl delete namespace argocd --ignore-not-found=true
        
        echo "✅ ArgoCD uninstalled"

    - name: ArgoCD Status Check
      run: |
        echo ""
        echo "📊 Final ArgoCD Status:"
        echo "======================="
        
        if kubectl get namespace argocd 2>/dev/null; then
          echo "✅ ArgoCD namespace exists"
          echo ""
          echo "Pod Status:"
          kubectl get pods -n argocd
          echo ""
          echo "Application Status:"
          kubectl get applications -n argocd 2>/dev/null || echo "No applications found"
        else
          echo "❌ ArgoCD is not installed"
        fi

    - name: GitOps Workflow Summary
      if: github.event.inputs.action != 'uninstall'
      run: |
        echo ""
        echo "🎉 GitOps Workflow Summary:"
        echo "=========================="
        echo ""
        echo "✅ ArgoCD installed and configured"
        echo "✅ Applications created for:"
        echo "   - ecommerce-microservices (k8s/)"
        echo "   - ecommerce-database (k8s/database/)"
        echo "   - ecommerce-monitoring (k8s/monitoring/)"
        echo ""
        echo "🔄 GitOps Workflow Active:"
        echo "   - Repository: https://github.com/${{ github.repository }}"
        echo "   - Auto-sync: Enabled"
        echo "   - Self-heal: Enabled"
        echo "   - Prune: Enabled"
        echo ""
        echo "📝 Next Steps:"
        echo "   1. Access ArgoCD UI to monitor deployments"
        echo "   2. Make changes to k8s/ manifests"
        echo "   3. Push changes to trigger GitOps sync"
        echo "   4. Monitor synchronization in ArgoCD dashboard"
        echo ""
        echo "🚀 Your GitOps workflow is ready!"

  sync-applications:
    name: 'Sync GitOps Applications'
    runs-on: ubuntu-latest
    needs: gitops-deployment
    if: github.ref == 'refs/heads/main' && (contains(github.event.head_commit.modified, 'k8s/') || github.event_name == 'workflow_dispatch')
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: ${{ env.KUBECTL_VERSION }}

    - name: Connect to AKS Cluster
      run: |
        # Try user-provided names first, then discover
        CLUSTER_NAME="${{ github.event.inputs.aks_cluster_name }}"
        RG_NAME="${{ github.event.inputs.resource_group_name }}"
        
        if [ -z "$CLUSTER_NAME" ] || [ -z "$RG_NAME" ]; then
          echo "🔍 Discovering AKS cluster..."
          AKS_CLUSTERS=$(az aks list --query "[?tags.Project=='aks-infra' && tags.Environment=='dev'].{name:name,resourceGroup:resourceGroup}" -o tsv 2>/dev/null || echo "")
          
          if [ -n "$AKS_CLUSTERS" ]; then
            CLUSTER_INFO=$(echo "$AKS_CLUSTERS" | head -n 1)
            CLUSTER_NAME=$(echo "$CLUSTER_INFO" | cut -f1)
            RG_NAME=$(echo "$CLUSTER_INFO" | cut -f2)
            echo "✅ Found cluster: $CLUSTER_NAME in $RG_NAME"
          else
            echo "❌ No AKS clusters found. Please ensure infrastructure is deployed first."
            exit 1
          fi
        fi
        
        echo "🔗 Connecting to AKS cluster: $CLUSTER_NAME in resource group: $RG_NAME"
        az aks get-credentials --resource-group "$RG_NAME" --name "$CLUSTER_NAME" --overwrite-existing
        kubectl cluster-info

    - name: Trigger ArgoCD Sync
      run: |
        echo "🔄 Triggering ArgoCD application sync..."
        
        # Check ArgoCD is installed
        if ! kubectl get namespace argocd 2>/dev/null; then
          echo "❌ ArgoCD is not installed. Run the ArgoCD installation first."
          exit 1
        fi
        
        # Get list of applications
        APPLICATIONS=$(kubectl get applications -n argocd -o name 2>/dev/null | sed 's/application.argoproj.io\///')
        
        if [ -z "$APPLICATIONS" ]; then
          echo "⚠️ No ArgoCD applications found"
          exit 0
        fi
        
        echo "Applications found: $APPLICATIONS"
        
        # Trigger sync for each application
        for app in $APPLICATIONS; do
          echo "Syncing application: $app"
          kubectl patch application "$app" -n argocd -p '{"operation":{"initiatedBy":{"username":"github-actions"},"sync":{"revision":"HEAD"}}}' --type merge || true
        done

    - name: Monitor Sync Status
      run: |
        echo "👀 Monitoring ArgoCD sync status..."
        
        # Wait for sync to complete
        timeout=300
        while [ $timeout -gt 0 ]; do
          echo ""
          echo "Application Status ($(date)):"
          kubectl get applications -n argocd -o custom-columns="NAME:.metadata.name,SYNC:.status.sync.status,HEALTH:.status.health.status,REVISION:.status.sync.revision" 2>/dev/null || true
          
          # Check if any application is still syncing
          SYNCING=$(kubectl get applications -n argocd -o jsonpath='{.items[*].status.sync.status}' 2>/dev/null | grep -c "Syncing" || echo "0")
          
          if [ "$SYNCING" -eq 0 ]; then
            echo ""
            echo "✅ All applications have completed synchronization"
            break
          fi
          
          echo "  ⏳ Waiting for sync completion... ($timeout seconds remaining)"
          sleep 10
          timeout=$((timeout-10))
        done
        
        if [ $timeout -le 0 ]; then
          echo "⚠️ Sync monitoring timed out after 5 minutes"
        fi

    - name: Final GitOps Status Report
      run: |
        echo ""
        echo "📊 GitOps Status Report:"
        echo "======================="
        
        # Application status
        echo ""
        echo "Application Health:"
        kubectl get applications -n argocd -o wide 2>/dev/null || echo "No applications found"
        
        # Get detailed status for each app
        APPLICATIONS=$(kubectl get applications -n argocd -o name 2>/dev/null | sed 's/application.argoproj.io\///')
        
        for app in $APPLICATIONS; do
          echo ""
          echo "Application: $app"
          SYNC_STATUS=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
          HEALTH_STATUS=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
          REVISION=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.sync.revision}' 2>/dev/null || echo "Unknown")
          
          echo "  Sync Status: $SYNC_STATUS"
          echo "  Health Status: $HEALTH_STATUS"
          echo "  Git Revision: $REVISION"
        done
        
        # ArgoCD UI access
        echo ""
        echo "🔗 ArgoCD UI Access:"
        ARGOCD_IP=$(kubectl get svc argocd-server-loadbalancer -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "Pending")
        if [ "$ARGOCD_IP" != "Pending" ]; then
          echo "   https://$ARGOCD_IP"
        else
          echo "   LoadBalancer IP pending - check: kubectl get svc argocd-server-loadbalancer -n argocd"
        fi
        
        echo ""
        echo "🎉 GitOps sync completed!"