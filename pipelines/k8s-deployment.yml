# Azure DevOps Pipeline for Kubernetes Microservices Deployment
# This pipeline only deploys microservices to an existing AKS cluster

trigger:
  branches:
    include:
    - main
    - develop
  paths:
    include:
    - k8s/**
    - scripts/deploy-microservices.*
    - pipelines/k8s-deployment.yml

pr:
  branches:
    include:
    - main
  paths:
    include:
    - k8s/**
    - scripts/deploy-microservices.*
    - pipelines/k8s-deployment.yml

parameters:
- name: aksClusterName
  displayName: 'AKS Cluster Name'
  type: string
  default: 'aks-cluster-dev'
- name: resourceGroupName
  displayName: 'Resource Group Name'
  type: string
  default: 'rg-aks-dev'
- name: deploymentMode
  displayName: 'Deployment Mode'
  type: string
  default: 'incremental'
  values:
  - incremental
  - full-redeploy

variables:
- name: kubernetesDirectory
  value: '$(System.DefaultWorkingDirectory)/k8s'
- name: azureServiceConnection
  value: 'azure-service-connection1'

stages:
- stage: ValidateManifests
  displayName: 'Validate Kubernetes Manifests'
  jobs:
  - job: ValidateK8s
    displayName: 'Validate YAML Files'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - task: KubectlInstaller@0
      displayName: 'Install kubectl'
      inputs:
        kubectlVersion: 'v1.28.0'
    
    - script: |
        echo "üîç Validating Kubernetes manifests..."
        find k8s/ -name "*.yaml" -o -name "*.yml" | while read file; do
          echo "  ‚úì Validating $file"
          kubectl apply --dry-run=client -f "$file" || exit 1
        done
        echo "‚úÖ All manifests are syntactically valid"
      displayName: 'Validate YAML Syntax'
    
    - script: |
        echo "üìä Analyzing resource specifications..."
        echo "Files with resource limits:"
        grep -r "limits:\|requests:" k8s/ | cut -d: -f1 | sort -u || echo "  No resource limits specified"
        
        echo ""
        echo "Files with secret references:"
        grep -r "secretKeyRef\|valueFrom:" k8s/ | cut -d: -f1 | sort -u || echo "  No secret references found"
        
        echo ""
        echo "Service types found:"
        grep -r "type:" k8s/ | grep -v "# " || echo "  No service types specified"
      displayName: 'Analyze Resource Specifications'

- stage: DeployMicroservices
  displayName: 'Deploy to AKS'
  dependsOn: ValidateManifests
  condition: succeeded()
  jobs:
  - deployment: DeployToAKS
    displayName: 'Deploy Microservices to AKS'
    environment: 'aks-microservices-deployment'
    pool:
      vmImage: 'ubuntu-latest'
    
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureCLI@2
            displayName: 'üîó Connect to AKS Cluster'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Connecting to AKS cluster: ${{ parameters.aksClusterName }} in resource group: ${{ parameters.resourceGroupName }}"
                az aks get-credentials --resource-group "${{ parameters.resourceGroupName }}" --name "${{ parameters.aksClusterName }}" --overwrite-existing
                
                echo "‚úÖ Connected to cluster"
                kubectl cluster-info
                kubectl get nodes --no-headers | wc -l | xargs echo "Node count:"
          
          - task: KubectlInstaller@0
            displayName: 'Install kubectl'
            inputs:
              kubectlVersion: 'v1.28.0'
          
          - task: PowerShell@2
            displayName: 'üìã Check Current Cluster State'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "üìã Current cluster state:" -ForegroundColor Cyan
                Write-Host "Namespaces:" -ForegroundColor Yellow
                $namespaces = kubectl get namespaces --no-headers 2>$null | Select-String "ecommerce|monitoring"
                if ($namespaces) {
                  $namespaces | ForEach-Object { Write-Host "  $_" }
                } else {
                  Write-Host "  No application namespaces found" -ForegroundColor Gray
                }
                
                Write-Host "`nExisting application pods:" -ForegroundColor Yellow
                $pods = kubectl get pods --all-namespaces --no-headers 2>$null | Select-String "ecommerce|monitoring"
                if ($pods) {
                  $pods | ForEach-Object { Write-Host "  $_" }
                } else {
                  Write-Host "  No application pods found" -ForegroundColor Gray
                }
          
          - task: Kubernetes@1
            displayName: 'üìÅ Deploy Namespaces'
            inputs:
              connectionType: 'None'
              command: 'apply'
              arguments: '-f $(kubernetesDirectory)/namespaces/ecommerce-namespace.yaml'
          
          - script: |
              echo "‚è≥ Waiting for namespaces to be ready..."
              kubectl wait --for=condition=Active --timeout=60s namespace/ecommerce
              kubectl wait --for=condition=Active --timeout=60s namespace/ecommerce-database  
              kubectl wait --for=condition=Active --timeout=60s namespace/monitoring
              echo "‚úÖ All namespaces are active"
            displayName: 'Wait for Namespaces'
          
          - task: Kubernetes@1
            displayName: 'üóÑÔ∏è Deploy Database'
            inputs:
              connectionType: 'None'
              command: 'apply'
              arguments: '-f $(kubernetesDirectory)/database/postgres-deployment.yaml'
          
          - script: |
              echo "‚è≥ Waiting for database to be ready..."
              kubectl wait --for=condition=available --timeout=300s deployment/postgres -n ecommerce-database
              echo "‚úÖ Database is ready"
            displayName: 'Wait for Database'
          
          - task: PowerShell@2
            displayName: 'üìä Database Status'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Database deployment status:" -ForegroundColor Green
                kubectl get pods -n ecommerce-database
                kubectl get svc -n ecommerce-database
          
          - task: Kubernetes@1
            displayName: 'üîß Deploy Backend Services'
            inputs:
              connectionType: 'None'
              command: 'apply'
              arguments: '-f $(kubernetesDirectory)/backend/backend-services.yaml'
          
          - script: |
              echo "‚è≥ Waiting for backend services to be ready..."
              kubectl wait --for=condition=available --timeout=300s deployment/user-service -n ecommerce
              kubectl wait --for=condition=available --timeout=300s deployment/product-service -n ecommerce
              echo "‚úÖ Backend services are ready"
            displayName: 'Wait for Backend Services'
          
          - task: PowerShell@2
            displayName: 'üîß Backend Services Status'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Backend services status:" -ForegroundColor Green
                kubectl get pods -n ecommerce -l 'app in (user-service,product-service)'
                kubectl get svc -n ecommerce -l 'app in (user-service,product-service)'
          
          - task: Kubernetes@1
            displayName: 'üåê Deploy Frontend'
            inputs:
              connectionType: 'None'
              command: 'apply'
              arguments: '-f $(kubernetesDirectory)/frontend/frontend-deployment.yaml'
          
          - script: |
              echo "‚è≥ Waiting for frontend to be ready..."
              kubectl wait --for=condition=available --timeout=300s deployment/frontend -n ecommerce
              echo "‚úÖ Frontend is ready"
            displayName: 'Wait for Frontend'
          
          - task: PowerShell@2
            displayName: 'üåê Frontend Status'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Frontend deployment status:" -ForegroundColor Green
                kubectl get pods -n ecommerce -l app=frontend
                kubectl get svc -n ecommerce -l app=frontend
          
          - task: Kubernetes@1
            displayName: 'üîÄ Deploy Ingress'
            inputs:
              connectionType: 'None'
              command: 'apply'
              arguments: '-f $(kubernetesDirectory)/ingress/ingress-config.yaml'
          
          - task: PowerShell@2
            displayName: 'üîÄ Ingress Status'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Ingress deployment status:" -ForegroundColor Green
                kubectl get ingress -n ecommerce
                kubectl get svc -n ecommerce ecommerce-loadbalancer
          
          - task: Kubernetes@1
            displayName: 'üìä Deploy Monitoring Stack'
            inputs:
              connectionType: 'None'
              command: 'apply'
              arguments: '-f $(kubernetesDirectory)/monitoring/monitoring-stack.yaml'
          
          - script: |
              echo "‚è≥ Waiting for monitoring stack to be ready..."
              kubectl wait --for=condition=available --timeout=300s deployment/prometheus -n monitoring
              kubectl wait --for=condition=available --timeout=300s deployment/grafana -n monitoring
              echo "‚úÖ Monitoring stack is ready"
            displayName: 'Wait for Monitoring Stack'
          
          - task: PowerShell@2
            displayName: 'üìä Monitoring Status'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Monitoring stack status:" -ForegroundColor Green
                kubectl get pods -n monitoring
                kubectl get svc -n monitoring
          
          - task: PowerShell@2
            displayName: 'üéâ Deployment Summary'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host ""
                Write-Host "üéâ ==================================" -ForegroundColor Green -BackgroundColor DarkGreen
                Write-Host "   MICROSERVICES DEPLOYMENT COMPLETE" -ForegroundColor Green -BackgroundColor DarkGreen
                Write-Host "   ==================================" -ForegroundColor Green -BackgroundColor DarkGreen
                Write-Host ""
                
                Write-Host "üìä PODS STATUS:" -ForegroundColor Cyan
                Write-Host "---------------" -ForegroundColor Cyan
                
                Write-Host "E-commerce Pods:" -ForegroundColor Yellow
                kubectl get pods -n ecommerce -o wide
                
                Write-Host "`nDatabase Pods:" -ForegroundColor Yellow
                kubectl get pods -n ecommerce-database -o wide
                
                Write-Host "`nMonitoring Pods:" -ForegroundColor Yellow
                kubectl get pods -n monitoring -o wide
                
                Write-Host "`nüåê SERVICES:" -ForegroundColor Cyan
                Write-Host "------------" -ForegroundColor Cyan
                kubectl get svc --all-namespaces | Select-String "ecommerce|monitoring" | Out-String -Stream | ForEach-Object { if ($_.Trim()) { Write-Host $_ } }
                
                Write-Host "`nüîÄ INGRESS:" -ForegroundColor Cyan
                Write-Host "-----------" -ForegroundColor Cyan
                kubectl get ingress -n ecommerce
          
          - task: PowerShell@2
            displayName: 'üì± Get Access Information'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "`nüì± ACCESS INFORMATION:" -ForegroundColor Yellow
                Write-Host "=====================" -ForegroundColor Yellow
                
                # Wait a bit for LoadBalancer IPs
                Write-Host "‚è≥ Checking for LoadBalancer IPs..."
                Start-Sleep -Seconds 30
                
                try {
                  $frontendIP = kubectl get svc ecommerce-loadbalancer -n ecommerce -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>$null
                  $grafanaIP = kubectl get svc grafana-service -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>$null
                }
                catch {
                  $frontendIP = ""
                  $grafanaIP = ""
                }
                
                Write-Host "`nüåê Frontend Application:" -ForegroundColor Green
                if ($frontendIP -and $frontendIP.Trim() -ne "") {
                  Write-Host "   URL: http://$frontendIP" -ForegroundColor White
                  Write-Host "   User API: http://$frontendIP/api/users" -ForegroundColor Gray
                  Write-Host "   Product API: http://$frontendIP/api/products" -ForegroundColor Gray
                } else {
                  Write-Host "   LoadBalancer IP: Pending" -ForegroundColor Yellow
                  Write-Host "   Check status: kubectl get svc ecommerce-loadbalancer -n ecommerce" -ForegroundColor Gray
                }
                
                Write-Host "`nüìä Grafana Dashboard:" -ForegroundColor Green
                if ($grafanaIP -and $grafanaIP.Trim() -ne "") {
                  Write-Host "   URL: http://$grafanaIP:3000" -ForegroundColor White
                  Write-Host "   Username: admin" -ForegroundColor White
                  Write-Host "   Password: admin123" -ForegroundColor White
                } else {
                  Write-Host "   LoadBalancer IP: Pending" -ForegroundColor Yellow
                  Write-Host "   Check status: kubectl get svc grafana-service -n monitoring" -ForegroundColor Gray
                }
                
                Write-Host "`nüîç Monitoring Commands:" -ForegroundColor Cyan
                Write-Host "   kubectl get pods --all-namespaces" -ForegroundColor Gray
                Write-Host "   kubectl get svc --all-namespaces" -ForegroundColor Gray
                Write-Host "   kubectl logs -f deployment/<name> -n <namespace>" -ForegroundColor Gray
          
          - task: PowerShell@2
            displayName: 'ü©∫ Final Health Check'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "`nü©∫ FINAL HEALTH CHECK:" -ForegroundColor Cyan
                Write-Host "=====================" -ForegroundColor Cyan
                
                # Check for failed pods
                $failedPods = (kubectl get pods --all-namespaces --field-selector=status.phase!=Running --no-headers 2>$null | Measure-Object).Count
                if ($failedPods -gt 0) {
                  Write-Host "‚ö†Ô∏è  Warning: $failedPods pods are not running" -ForegroundColor Yellow
                  kubectl get pods --all-namespaces --field-selector=status.phase!=Running
                } else {
                  Write-Host "‚úÖ All pods are running successfully" -ForegroundColor Green
                }
                
                # Check service endpoints
                Write-Host "`nService endpoints:" -ForegroundColor Yellow
                $endpoints = kubectl get endpoints --all-namespaces --no-headers 2>$null | Select-String "ecommerce|monitoring"
                if ($endpoints) {
                  $endpoints | ForEach-Object { Write-Host "  $_" }
                } else {
                  Write-Host "  No application endpoints found" -ForegroundColor Gray
                }
                
                Write-Host "`nüöÄ Deployment completed successfully!" -ForegroundColor Green